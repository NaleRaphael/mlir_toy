## Folder structure
```
src/Ch2/
├── build_dialect.sh    # The script to build Toy dialect with CMake
├── toy/
│   ├── c/        # Headers and impls of Toy dialect C-API
│   └── cpp/      # Headers and impls of Toy dialect
├── build_toy/    # (generated after building)
│   └── toy/cpp/  # - Files generated by tablegen
└── inst_toy/     # (generated after building)
    └── lib/      # - Libraries of Toy dialect and C-API
```

In "toy/cpp" folder, files are almost directly inheriting from the
["mlir/examples/toy/Ch2"][1] with slight changes:
- "CMakeLists.txt": some CMake macros for MLIR things are rewritten.
- "Dialect.cpp": file paths to include are revised
- "Dialect.h": file paths to include are revised
- "Helper.h": a new file added to extend the type supports for toy dialect in
  our C API.

In "toy/c" folder, files contain implementations of C APIs to use in our Zig
code.

## Development
### For Zig code
- To build the code, it's recommended to run with the `build.zig` in the root
  of this project directory. Please check out [build.sh](../../build.sh) for
  details.
- By default, dialect will be built along with the selected chapter. If you
  want to built the dialect on your own or via `build_dialect.sh` in this
  folder, you can disable it by passing the flag `-Dbuild_dialect=false`.

### For C++ code
- You can run `build_dialect.sh` to build the toy dialect directly. (remember
  to pass the `MLIR_DIR` env variable based on your case).
- You can create a symlink of `compile_commands.json` from build directory
  "build_toy" to this directory to make `clangd` work with your editor.

## Note
- In custom C APIs, to make `wrap()` and `unwrap()` work for Ops defined in toy
  dialect, remember to apply the following marcos to the types you want to use.
  (see also "toy/cpp/Helper.h")
  - `DEFINE_C_API_METHODS`: for value type
  - `DEFINE_C_API_PTR_METHODS`: for pointer type
- If you are also re-implementing this chapter, you might find the generated
  MLIR would contain some extra markers like "^bb0" (block label) when your
  codegen is not finished yet. You can ignore that and just compare the output
  with the one generated from `toyc-chX`, and those markers will not be printed
  out when the codegen is finished.


[1]: https://github.com/llvm/llvm-project/tree/release/17.x/mlir/examples/toy/Ch2
